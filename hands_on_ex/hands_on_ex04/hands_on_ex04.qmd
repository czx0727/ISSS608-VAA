---
title: "Hands-on Ex 4"
author: "Chai Zhixuan"
date: 2024-01-14
date-format: long
date-modified: "last-modified"
---

# **Getting Started**

This hands-on exercise covers all of the information from this [link](https://isss608-ay2023-24jan.netlify.app/outline/lesson04_outline).

-   [Hands-on Exercise 4: Visualising Distribution](https://r4va.netlify.app/chap09)

-   [Hands-on Exercise 4: Visual Statistical Analysis](https://r4va.netlify.app/chap10)

-   [Hands-on Exercise 4: Visualising Uncertainty](https://r4va.netlify.app/chap11)

-   [Hands-on Exercise 4: Building Funnel Plot with R](https://r4va.netlify.app/chap12)

::: callout-note
## Zhixuan's personal learning outcomes:

1.  Understand and do visualisation distribution
2.  Understand and apply visual statistical analysis
3.  Understand and apply visualizing uncertainty
4.  Understand and apply Funnel Plots for Fair Comparisons
5.  Apply and link it to take home exercise, project and work
:::

# **1 Visualising Distribution**

For the purpose of this exercise, the following R packages will be used, they are:

-   tidyverse, a family of R packages for data science process,

-   ggridges, a ggplot2 extension specially designed for plotting ridgeline plots, and

-   ggdist for visualising distribution and uncertainty.

```{r}
pacman::p_load(ggdist, ggridges, ggthemes,
               colorspace, tidyverse)
```

*Exam_data.csv*Â will be used again ðŸ¤£

```{r}
exam <- read_csv("data/Exam_data.csv")
```

## **Visualising Distribution with Ridgeline Plot**

The ridgeline plot below is plotted by usingÂ `geom_density_ridges()`. Please read more from [here](https://r4va.netlify.app/chap09#visualising-distribution-with-ridgeline-plot).

::: panel-tabset
## The plot

```{r, echo=FALSE, warning=FALSE}
#| eval: true
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,
    rel_min_height = 0.01,
    bandwidth = 3.4,
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()

```

## The code

```{r}
#| eval: false

ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,
    rel_min_height = 0.01,
    bandwidth = 3.4,
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```
:::

I will try with **Math scores**:

```{r}
ggplot(exam, 
       aes(x = MATHS, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,
    rel_min_height = 0.01,
    bandwidth = 3.4,
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "Math grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

### **Varying fill colors along the x axis**

::: panel-tabset
## The plot

```{r, echo=FALSE, warning=FALSE}
#| eval: true
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "Temp. [F]",
                       option = "C") +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()

```

## The code

```{r}
#| eval: false
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "Temp. [F]",
                       option = "C") +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```
:::

::: callout-note
Colour seems to be nice
:::

I try with **Math Score**

```{r}
ggplot(exam, 
       aes(x = MATHS, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "Temp. [F]",
                       option = "C") +
  scale_x_continuous(
    name = "Math grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

### **Mapping the probabilities directly onto colour**

From prof, figure below is plotted by mapping the probabilities calculated by usingÂ `stat(ecdf)`Â which represent the empirical cumulative density function for the distribution of English score.

::: panel-tabset
## The plot

```{r, echo=FALSE, warning=FALSE}
#| eval: true

ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = 0.5 - abs(0.5-stat(ecdf)))) +
  stat_density_ridges(geom = "density_ridges_gradient", 
                      calc_ecdf = TRUE) +
  scale_fill_viridis_c(name = "Tail probability",
                       direction = -1) +
  theme_ridges()

```

## The code

```{r}
#| eval: false

ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = 0.5 - abs(0.5-stat(ecdf)))) +
  stat_density_ridges(geom = "density_ridges_gradient", 
                      calc_ecdf = TRUE) +
  scale_fill_viridis_c(name = "Tail probability",
                       direction = -1) +
  theme_ridges()

```
:::

### **Ridgeline plots with quantile lines**

By usingÂ [`geom_density_ridges_gradient()`](https://wilkelab.org/ggridges/reference/geom_ridgeline_gradient.html), we can colour the ridgeline plot by quantile, via the calculatedÂ `stat(quantile)`Â aesthetic as shown in the figure below.

::: panel-tabset
## The plot

```{r, echo=FALSE, warning=FALSE}
#| eval: true


ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = 4,
    quantile_lines = TRUE) +
  scale_fill_viridis_d(name = "Quartiles") +
  theme_ridges()
```

## The code

```{r}
#| eval: false
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = 4,
    quantile_lines = TRUE) +
  scale_fill_viridis_d(name = "Quartiles") +
  theme_ridges()
```
:::

I can specify quantiles by cut points such as 2.5% and 97.5% tails to colour the ridgeline plot as shown below.

```{r}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = c(0.025, 0.975)
    ) +
  scale_fill_manual(
    name = "Probability",
    values = c("#FF0000A0", "#A0A0A0A0", "#0000FFA0"),
    labels = c("(0, 0.025]", "(0.025, 0.975]", "(0.975, 1]")
  ) +
  theme_ridges()
```

## **Visualising Distribution with Raincloud Plot**

### **Plotting a Half Eye graph**

I will plot a Half-Eye graph by using [`stat_halfeye()`](https://mjskay.github.io/ggdist/reference/stat_halfeye.html) of **ggdist** package.

This will produce a Half Eye visualization, which is contains a half-density and a slab-interval.

```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA)
```

### **Adding the boxplot with `geom_boxplot()`**

Next, we will add the second geometry layer usingÂ [`geom_boxplot()`](https://r4va.netlify.app/chap09)Â of ggplot2. This produces a narrow boxplot. We reduce the width and adjust the opacity.

```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA)
```

### **Adding the Dot Plots with `stat_dots()`**

```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 2)
```

### **Finishing touch**

```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 1.5) +
  coord_flip() +
  theme_economist()
```

Let me try with Math data and another theme ðŸ’ª

```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = MATHS)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 1.5) +
  coord_flip() +
  theme_wsj()
```

# 2 **Visual Statistical Analysis**

```{r}
pacman::p_load(ggstatsplot, tidyverse)
```

### **One-sample test: *gghistostats()* method**

In the code chunk below,Â [*gghistostats()*](https://indrajeetpatil.github.io/ggstatsplot/reference/gghistostats.html)Â is used to to build an visual of one-sample test on English scores.

```{r}

set.seed(1234)

gghistostats(
  data = exam,
  x = ENGLISH,
  type = "bayes",
  test.value = 60,
  xlab = "English scores"
)
```

I will try with Math scores

```{r}
set.seed(1234)

gghistostats(
  data = exam,
  x = MATHS,
  type = "bayes",
  test.value = 60,
  xlab = "Math scores"
)
```

### **How to interpret Bayes Factor**

### **Two-sample mean test: *ggbetweenstats()***

```{r}
ggbetweenstats(
  data = exam,
  x = GENDER, 
  y = MATHS,
  type = "np",
  messages = FALSE
)
```

I try with English score

```{r}
ggbetweenstats(
  data = exam,
  x = GENDER, 
  y = ENGLISH,
  type = "np",
  messages = FALSE
)
```

### **Oneway ANOVA Test: *ggbetweenstats()* method**

[*ggbetweenstats()*](https://indrajeetpatil.github.io/ggstatsplot/reference/ggbetweenstats.html)Â is used to build a visual for One-way ANOVA test on English score by race.

```{r}
ggbetweenstats(
  data = exam,
  x = RACE, 
  y = ENGLISH,
  type = "p",
  mean.ci = TRUE, 
  pairwise.comparisons = TRUE, 
  pairwise.display = "s",
  p.adjust.method = "fdr",
  messages = FALSE
)
```

```{r}
ggbetweenstats(
  data = exam,
  x = RACE, 
  y = MATHS,
  type = "p",
  mean.ci = TRUE, 
  pairwise.comparisons = TRUE, 
  pairwise.display = "s",
  p.adjust.method = "fdr",
  messages = FALSE
)
```

### **Significant Test of Correlation: *ggscatterstats()***

```{r}
ggscatterstats(
  data = exam,
  x = MATHS,
  y = ENGLISH,
  marginal = FALSE,
  )
```

### **Significant Test of Association (Depedence) : *ggbarstats()* methods**

```{r}
exam1 <- exam %>% 
  mutate(MATHS_bins = 
           cut(MATHS, 
               breaks = c(0,60,75,85,100))
)
```

```{r}
ggbarstats(exam1, 
           x = MATHS_bins, 
           y = GENDER)
```

## **Visualising Models**

## **Installing and loading the required libraries**

```{r}
pacman::p_load(readxl, performance, parameters, see)
```

### **Importing Excel file: readxl methods**

```{r}
car_resale <- read_xls("data/ToyotaCorolla.xls", 
                       "data")
car_resale
```

### **Multiple Regression Model using lm()**

```{r}
model <- lm(Price ~ Age_08_04 + Mfg_Year + KM + 
              Weight + Guarantee_Period, data = car_resale)
model
```

### **Model Diagnostic: checking for multicolinearity**

```{r}
check_collinearity(model)
```

```{r}
check_c <- check_collinearity(model)
plot(check_c)
```

### **Model Diagnostic: checking normality assumption**

```{r}
model1 <- lm(Price ~ Age_08_04 + KM + 
              Weight + Guarantee_Period, data = car_resale)
```

```{r}
check_n <- check_normality(model1)
```

```{r}
plot(check_n)
```

### **Model Diagnostic: Check model for homogeneity of variances**

```{r}
check_h <- check_heteroscedasticity(model1)
```

```{r}
plot(check_h)
```

### **Model Diagnostic: Complete check**

```{r}
check_model(model1)
```

### **Visualising Regression Parameters: see methods**

```{r}
plot(parameters(model1))
```

### **Visualising Regression Parameters: *ggcoefstats()* methods**

```{r}
ggcoefstats(model1, 
            output = "plot")
```

# 3 **Visualising Uncertainty**

Exam data will be used again! ðŸ˜€

```{r}
#| eval: false
devtools::install_github("wilkelab/ungeviz",force = TRUE)
```

```{r}
pacman::p_load(ungeviz, plotly, crosstalk,
               DT, ggdist, ggridges,
               colorspace, gganimate, tidyverse)
```

## **Visualizing the uncertainty of point estimates: ggplot2 methods**

```{r}

my_sum <- exam %>%
  group_by(RACE) %>%
  summarise(
    n=n(),
    mean=mean(MATHS),
    sd=sd(MATHS)
    ) %>%
  mutate(se=sd/sqrt(n-1))
```

Next, the code chunk below will be used to displayÂ *my_sum*Â tibble data frame in an html table format.

```{r}

knitr::kable(head(my_sum), format = 'html')
```

### **Plotting standard error bars of point estimates**

Now I will plot the standard error bars of mean maths score by race as shown below.

```{r}
ggplot(my_sum) +
  geom_errorbar(
    aes(x=RACE, 
        ymin=mean-se, 
        ymax=mean+se), 
    width=0.2, 
    colour="black", 
    alpha=0.9, 
    size=0.5) +
  geom_point(aes
           (x=RACE, 
            y=mean), 
           stat="identity", 
           color="red",
           size = 1.5,
           alpha=1) +
  ggtitle("Standard error of mean maths score by rac")
```

### **Plotting confidence interval of point estimates**

I can plot the confidence intervals of mean maths score by race.

```{r}

ggplot(my_sum) +
  geom_errorbar(
    aes(x=reorder(RACE, -mean), 
        ymin=mean-1.96*se, 
        ymax=mean+1.96*se), 
    width=0.2, 
    colour="black", 
    alpha=0.9, 
    size=0.5) +
  geom_point(aes
           (x=RACE, 
            y=mean), 
           stat="identity", 
           color="red",
           size = 1.5,
           alpha=1) +
  labs(x = "Maths score",
       title = "95% confidence interval of mean maths score by race")
```

### **Visualizing the uncertainty of point estimates with interactive error bars**

I learn how to plot interactive error bars for the 99% confidence interval of mean maths score by race:

```{r}

shared_df = SharedData$new(my_sum)

bscols(widths = c(4,8),
       ggplotly((ggplot(shared_df) +
                   geom_errorbar(aes(
                     x=reorder(RACE, -mean),
                     ymin=mean-2.58*se, 
                     ymax=mean+2.58*se), 
                     width=0.2, 
                     colour="black", 
                     alpha=0.9, 
                     size=0.5) +
                   geom_point(aes(
                     x=RACE, 
                     y=mean, 
                     text = paste("Race:", `RACE`, 
                                  "<br>N:", `n`,
                                  "<br>Avg. Scores:", round(mean, digits = 2),
                                  "<br>95% CI:[", 
                                  round((mean-2.58*se), digits = 2), ",",
                                  round((mean+2.58*se), digits = 2),"]")),
                     stat="identity", 
                     color="red", 
                     size = 1.5, 
                     alpha=1) + 
                   xlab("Race") + 
                   ylab("Average Scores") + 
                   theme_minimal() + 
                   theme(axis.text.x = element_text(
                     angle = 45, vjust = 0.5, hjust=1)) +
                   ggtitle("99% Confidence interval of average /<br>maths scores by race")), 
                tooltip = "text"), 
       DT::datatable(shared_df, 
                     rownames = FALSE, 
                     class="compact", 
                     width="100%", 
                     options = list(pageLength = 10,
                                    scrollX=T), 
                     colnames = c("No. of pupils", 
                                  "Avg Scores",
                                  "Std Dev",
                                  "Std Error")) %>%
         formatRound(columns=c('mean', 'sd', 'se'),
                     digits=2))
```

## **Visualising Uncertainty: [ggdist package](https://mjskay.github.io/ggdist/)**

### **Visualizing the uncertainty of point estimates: ggdist methods**

```{r}

exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_pointinterval() +
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Mean Point + Multiple-interval plot")
```

```{r}

exam %>%
  ggplot(aes(x = RACE, y = MATHS)) +
  stat_pointinterval(.width = 0.95,
  .point = median,
  .interval = qi) +
  labs(
    title = "Visualising confidence intervals of median math score",
    subtitle = "Median Point + Multiple-interval plot")
```

I plot with English score

```{r}

exam %>%
  ggplot(aes(x = RACE, y = ENGLISH)) +
  stat_pointinterval(.width = 0.95,
  .point = median,
  .interval = qi) +
  labs(
    title = "Visualising confidence intervals of median english score",
    subtitle = "Median Point + Multiple-interval plot")
```

### **Visualizing the uncertainty of point estimates: ggdist methods**

Â [`stat_gradientinterval()`](https://mjskay.github.io/ggdist/reference/stat_gradientinterval.html)Â ofÂ **ggdist**Â is used to build a visual for displaying distribution of maths scores by race.

```{r}

exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_pointinterval(
    show.legend = FALSE) +   
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Mean Point + Multiple-interval plot")
```

### **Visualizing the uncertainty of point estimates: ggdist methods**

```{r}

exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_gradientinterval(   
    fill = "skyblue",      
    show.legend = TRUE     
  ) +                        
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Gradient + interval plot")
```

::: callout-note
This is nice!
:::

## **Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)**

```{r}
#| eval: false
devtools::install_github("wilkelab/ungeviz")
```

```{r}
library(ungeviz)
```

```{r}

ggplot(data = exam, 
       (aes(x = factor(RACE), y = MATHS))) +
  geom_point(position = position_jitter(
    height = 0.3, width = 0.05), 
    size = 0.4, color = "#0072B2", alpha = 1/2) +
  geom_hpline(data = sampler(25, group = RACE), height = 0.6, color = "#D55E00") +
  theme_bw() + 
  # `.draw` is a generated column indicating the sample draw
  transition_states(.draw, 1, 3)
```

ðŸ˜±ðŸ˜±ðŸ˜±

## **Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)**

```{r}

ggplot(data = exam, 
       (aes(x = factor(RACE), 
            y = MATHS))) +
  geom_point(position = position_jitter(
    height = 0.3, 
    width = 0.05), 
    size = 0.4, 
    color = "#0072B2", 
    alpha = 1/2) +
  geom_hpline(data = sampler(25, 
                             group = RACE), 
              height = 0.6, 
              color = "#D55E00") +
  theme_bw() + 
  transition_states(.draw, 1, 3)
```

ðŸ˜±ðŸ˜±ðŸ˜±

# 4 **Funnel Plots for Fair Comparisons**

## **Installing and Launching R Packages**

```{r}
pacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)
```

## **Importing Data**

```{r}
covid19 <- read_csv("data/COVID-19_DKI_Jakarta.csv") %>%
  mutate_if(is.character, as.factor)
```

## **FunnelPlotR methods**

```{r}
funnel_plot(
  numerator = covid19$Positive,
  denominator = covid19$Death,
  group = covid19$`Sub-district`
)
```

### **FunnelPlotR methods: Makeover 1**

```{r}
funnel_plot(
  numerator = covid19$Death,
  denominator = covid19$Positive,
  group = covid19$`Sub-district`,
  data_type = "PR",     #<<
  xrange = c(0, 6500),  #<<
  yrange = c(0, 0.05)   #<<
)
```

### **FunnelPlotR methods: Makeover 2**

```{r}
funnel_plot(
  numerator = covid19$Death,
  denominator = covid19$Positive,
  group = covid19$`Sub-district`,
  data_type = "PR",   
  xrange = c(0, 6500),  
  yrange = c(0, 0.05),
  label = NA,
  title = "Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases", #<<           
  x_label = "Cumulative COVID-19 Positive Cases", #<<
  y_label = "Cumulative Fatality Rate"  #<<
)
```

::: callout-note
This looks good!!
:::

## **Funnel Plot for Fair Visual Comparison: ggplot2 methods**

### **Computing the basic derived fields**

To plot the funnel plot from scratch, we need to derive cumulative death rate and standard error of cumulative death rate.

```{r}
df <- covid19 %>%
  mutate(rate = Death / Positive) %>%
  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %>%
  filter(rate > 0)
```

Next, theÂ *fit.mean*Â is computed by using the code chunk below.

```{r}
fit.mean <- weighted.mean(df$rate, 1/df$rate.se^2)
```

### **Calculate lower and upper limits for 95% and 99.9% CI**

The code chunk below is used to compute the lower and upper limits for 95% confidence interval.

```{r}
number.seq <- seq(1, max(df$Positive), 1)
number.ll95 <- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ul95 <- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ll999 <- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ul999 <- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
dfCI <- data.frame(number.ll95, number.ul95, number.ll999, 
                   number.ul999, number.seq, fit.mean)
```

### **Plotting a static funnel plot**

ggplot2 functions are used to plot a static funnel plot.

```{r}
p <- ggplot(df, aes(x = Positive, y = rate)) +
  geom_point(aes(label=`Sub-district`), 
             alpha=0.4) +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ll95), 
            size = 0.4, 
            colour = "grey40", 
            linetype = "dashed") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ul95), 
            size = 0.4, 
            colour = "grey40", 
            linetype = "dashed") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ll999), 
            size = 0.4, 
            colour = "grey40") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ul999), 
            size = 0.4, 
            colour = "grey40") +
  geom_hline(data = dfCI, 
             aes(yintercept = fit.mean), 
             size = 0.4, 
             colour = "grey40") +
  coord_cartesian(ylim=c(0,0.05)) +
  annotate("text", x = 1, y = -0.13, label = "95%", size = 3, colour = "grey40") + 
  annotate("text", x = 4.5, y = -0.18, label = "99%", size = 3, colour = "grey40") + 
  ggtitle("Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases") +
  xlab("Cumulative Number of COVID-19 Cases") + 
  ylab("Cumulative Fatality Rate") +
  theme_light() +
  theme(plot.title = element_text(size=12),
        legend.position = c(0.91,0.85), 
        legend.title = element_text(size=7),
        legend.text = element_text(size=7),
        legend.background = element_rect(colour = "grey60", linetype = "dotted"),
        legend.key.height = unit(0.3, "cm"))
p
```

::: callout-note
Seems to be a bit confusing to me. Will try to understand the plot
:::

### **Interactive Funnel Plot: plotly + ggplot2**

```{r}
fp_ggplotly <- ggplotly(p,
  tooltip = c("label", 
              "x", 
              "y"))
fp_ggplotly
```

ðŸ˜±
