---
title: "Hands-on Ex 5"
author: "Chai Zhixuan"
date: 2024-01-21
date-format: long
date-modified: "last-modified"
---

# **Getting Started**

This hands-on exercise covers all of the information from this [link](https://isss608-ay2023-24jan.netlify.app/outline/lesson05_outline).

-   [Building Ternary Plot with R](https://r4va.netlify.app/chap13).

-   [Visual Correlation Analysis](https://r4va.netlify.app/chap06).

-   [Visual Multivariate Analysis with Heatmap](https://r4va.netlify.app/chap14).

-   [Visual Multivariate Analysis with Parallel Coordinates Plot](https://r4va.netlify.app/chap15).

-   [Treemap Visualisation with R](https://r4va.netlify.app/chap16)

ðŸ˜± So many exercises in one hands-on!

::: callout-note
## Zhixuan's personal outcome

1.  I will try to follow all and learn all these (despite CNY ðŸ˜‚)
:::

# **1. Creating Ternary Plot with R**

## **Installing and launching R packages**

2 main R packages will be used in this hands-on exercise, they are:

-   [**ggtern**](http://www.ggtern.com/), a ggplot extension specially designed to plot ternary diagrams. The package will be used to plot static ternary plots.

-   [**Plotly R**](https://plot.ly/r/), an R package for creating interactive web-based graphs via plotly's JavaScript graphing library, plotly.js . The **plotly R** libary contains the *ggplotly* function, which will convert **ggplot2** figures into a Plotly object.

```{r}
pacman::p_load('plotly', 'tidyverse')
```

```{r}
#| eval: false
require(devtools)
install_version("ggtern", version = "3.4.1", repos = "http://cran.us.r-project.org")
```

::: callout-note
ggtern is version 3.2.1. It can be used for this exercise ðŸ˜€
:::

```{r}
library(ggtern)
```

### **Importing Data**

```{r}
pop_data <- read_csv("data/respopagsex2000to2018_tidy.csv") 
```

### **Preparing the Data**

I will use the [mutate function](https://dplyr.tidyverse.org/reference/mutate.html) to derive 3 new measures: young, active and old:

```{r}
agpop_mutated <- pop_data %>%
  mutate(`Year` = as.character(Year))%>%
  spread(AG, Population) %>%
  mutate(YOUNG = rowSums(.[4:8]))%>%
  mutate(ACTIVE = rowSums(.[9:16]))  %>%
  mutate(OLD = rowSums(.[17:21])) %>%
  mutate(TOTAL = rowSums(.[22:24])) %>%
  filter(Year == 2018)%>%
  filter(TOTAL > 0)
```

## **Plotting Ternary Diagram with R**

UseÂ ***ggtern()***Â function ofÂ **ggtern**Â package to create a simple ternary plot.

```{r}
ggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point()
```

```{r}
ggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +
  geom_point() +
  labs(title="Population structure, 2015") +
  theme_rgbw()
```

### **Plotting an interative ternary diagram**

I will use the ***plot_ly()***Â function ofÂ **Plotly R**.

```{r}
# reusable function for creating annotation object
label <- function(txt) {
  list(
    text = txt, 
    x = 0.1, y = 1,
    ax = 0, ay = 0,
    xref = "paper", yref = "paper", 
    align = "center",
    font = list(family = "serif", size = 15, color = "white"),
    bgcolor = "#b3b3b3", bordercolor = "black", borderwidth = 2
  )
}

# reusable function for axis formatting
axis <- function(txt) {
  list(
    title = txt, tickformat = ".0%", tickfont = list(size = 10)
  )
}

ternaryAxes <- list(
  aaxis = axis("Young"), 
  baxis = axis("Active"), 
  caxis = axis("Old")
)

# Initiating a plotly visualization 
plot_ly(
  agpop_mutated, 
  a = ~YOUNG, 
  b = ~ACTIVE, 
  c = ~OLD, 
  color = I("black"), 
  type = "scatterternary"
) %>%
  layout(
    annotations = label("Ternary Markers"), 
    ternary = ternaryAxes
  )
```

# **2. Visual Correlation Analysis**

## **Installing and Launching R Packages**

I will use the following packages below:

```{r}
pacman::p_load(corrplot, ggstatsplot, tidyverse)
```

### **Importing Data**

```{r}
wine <- read_csv("data/wine_quality.csv")
```

## **Building Correlation Matrix: *pairs()* method**

### **Building a basic correlation matrix**

A scatter plot matrix of Wine Quality Data is plotted below. It is a 11 by 11 matrix.

```{r}
pairs(wine[,1:11])
```

```{r}
pairs(wine[,2:12])
```

### **Drawing the lower corner**

To show the lower half of the correlation matrix, the upper.panel argument will be used as shown in the code chunk below.

```{r}
pairs(wine[,2:12], upper.panel = NULL)
```

Similarly, you can display the upper half of the correlation matrix by using the code chun below.

```{r}
pairs(wine[,2:12], lower.panel = NULL)
```

### **Including with correlation coefficients**

To show the correlation coefficient of each pair of variables instead of a scatter plot,Â [*panel.cor*](https://www.rdocumentation.org/packages/xcms/versions/1.48.0/topics/panel.cor)Â function will be used. This will also show higher correlations in a larger font.

```{r, warning = FALSE}

panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y, use="complete.obs"))
txt <- format(c(r, 0.123456789), digits=digits)[1]
txt <- paste(prefix, txt, sep="")
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)
}

pairs(wine[,2:12], 
      upper.panel = panel.cor)
```

## **Visualising Correlation Matrix: ggcormat()**

One of the major limitation of the correlation matrix is that the scatter plots appear very cluttered when the number of observations is relatively large (i.e.Â more than 500 observations). To over come this problem,Â **Corrgram**Â data visualisation technique suggested by D. J. Murdoch and E. D. Chow (1996) and Friendly, M (2002) and will be used.

```{r}
#| eval: false
ggstatsplot::ggcorrmat(data = wine, cor.vars = 1:11)
```

```{r}
#| eval: false
ggstatsplot::ggcorrmat(
  data = wine, 
  cor.vars = 1:11,
  ggcorrplot.args = list(outline.color = "black", 
                         hc.order = TRUE,
                         tl.cex = 10),
  title    = "Correlogram for wine dataset",
  subtitle = "Four pairs are no significant at p < 0.05"
)
```

```{r}
#| eval: false
ggplot.component = list(
    theme(text=element_text(size=5),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8)))
```

## **Building multiple plots**

[*grouped_ggcorrmat()*](https://indrajeetpatil.github.io/ggstatsplot/reference/grouped_ggcorrmat.html)Â ofÂ **ggstatsplot**. is used

```{r}
grouped_ggcorrmat(
  data = wine,
  cor.vars = 1:11,
  grouping.var = type,
  type = "robust",
  p.adjust.method = "holm",
  plotgrid.args = list(ncol = 2),
  ggcorrplot.args = list(outline.color = "black", 
                         hc.order = TRUE,
                         tl.cex = 10),
  annotation.args = list(
    tag_levels = "a",
    title = "Correlogram for wine dataset",
    subtitle = "The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity",
    caption = "Dataset: UCI Machine Learning Repository"
  )
)
```

## **Visualising Correlation Matrix using corrplot Package**

### **Getting started with corrplot**

In the code chunk below,Â [*cor()*](https://www.rdocumentation.org/packages/stats/versions/3.6.0/topics/cor)Â of R Stats is used to compute the correlation matrix of wine data frame.

```{r}
wine.cor <- cor(wine[, 1:11])
```

Next,Â [*corrplot()*](https://www.rdocumentation.org/packages/corrplot/versions/0.2-0/topics/corrplot)Â is used to plot the corrgram by using all the default setting as shown in the code chunk below.

```{r}
corrplot(wine.cor)
```

### **Working with visual geometrics**

The default visual geometric of corrplot matrix is circle. However, this default setting can be changed by using theÂ *method*Â argument as shown in the code chunk below.

```{r}
corrplot(wine.cor, 
         method = "ellipse") 
```

::: callout-note
I try with other methods - square and pie
:::

```{r}
corrplot(wine.cor, 
         method = "square") 
```

```{r}
corrplot(wine.cor, 
         method = "pie") 
```

### **Working with layout**

*corrplor()*Â supports three layout types, namely: "full", "upper" or "lower". The default is "full" which display full matrix. The default setting can be changed by using theÂ *type*Â argument ofÂ *corrplot()*.

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower")
```

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower",
         diag = FALSE,
         tl.col = "black")
```

::: callout-note
I try with other method
:::

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower",
         diag = FALSE,
         tl.srt = 45)
```

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower",
         diag = FALSE,
         tl.pos = 'n')
```

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         type="lower",
         diag = FALSE,
         tl.cex = 0.5)
```

### **Working with mixed layout**

In order to create a coorgram with mixed layout, the [*corrplot.mixed()*](https://www.rdocumentation.org/packages/corrplot/versions/0.84/topics/corrplot.mixed), a wrapped function for mixed visualisation style will be used.

Figure below shows a mixed layout corrgram plotted using wine quality data.

```{r}
corrplot.mixed(wine.cor, 
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

```{r}
corrplot.mixed(wine.cor, 
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

### **Combining corrgram with the significant test**

With corrplot package, we can use theÂ *cor.mtest()*Â to compute the p-values and confidence interval for each pair of variables.

```{r}
wine.sig = cor.mtest(wine.cor, conf.level= .95)
```

```{r}
corrplot(wine.cor,
         method = "number",
         type = "lower",
         diag = FALSE,
         tl.col = "black",
         tl.srt = 45,
         p.mat = wine.sig$p,
         sig.level = .05)
```

### **Reorder a corrgram**

```{r}
corrplot.mixed(wine.cor, 
               lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               order="AOE",
               tl.col = "black")
```

### **Reordering a correlation matrix using hclust**

If usingÂ **hclust**,Â ***corrplot()***Â can draw rectangles around the corrgram based on the results of hierarchical clustering.

```{r}
corrplot(wine.cor, 
         method = "ellipse", 
         tl.pos = "lt",
         tl.col = "black",
         order="hclust",
         hclust.method = "ward.D",
         addrect = 3)
```

# **3. Heatmap for Visualising and Analysing Multivariate Data**

## **Installing and Launching R Packages**

```{r}
pacman::p_load(seriation, dendextend, heatmaply, tidyverse)
```

## **Importing and Preparing The Data Set**

### **Importing the data set**

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

### **Preparing the data**

```{r}
row.names(wh) <- wh$Country
```

### **Transforming the data frame into a matrix**

The code chunk below will be used to transformÂ *wh*Â data frame into a data matrix.

```{r}
wh1 <- dplyr::select(wh, c(3, 7:12))
wh_matrix <- data.matrix(wh)
```

### **heatmap() of R Stats**

In this sub-section, we will plot a heatmap by usingÂ *heatmap()*Â of Base Stats. The code chunk is given below.

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      Rowv=NA, Colv=NA)
```

```{r}
wh_heatmap <- heatmap(wh_matrix)
```

```{r}
wh_heatmap <- heatmap(wh_matrix,
                      scale="column",
                      cexRow = 0.6, 
                      cexCol = 0.8,
                      margins = c(10, 4))
```

## **Creating Interactive Heatmap**

### **Working with heatmaply**

[**heatmaply**](http://talgalili.github.io/heatmaply/)Â is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file. It is designed and maintained by Tal Galili.

```{r}
heatmaply(mtcars)
```

The code chunk below shows the basic syntax needed to create n interactive heatmap by usingÂ **heatmaply**Â package.

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)])
```

### **Data trasformation**

#### Scaling method

```{r}
heatmaply(wh_matrix[, -c(1, 2, 4, 5)],
          scale = "column")
```

#### Normalising method

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))
```

#### Percentising method

```{r}
heatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))
```

### **Clustering algorithm**

### **Manual approach**

In the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with "Euclidean distance" and "ward.D" method.

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "ward.D")
```

### **Statistical approach**

In order to determine the best clustering method and number of cluster the *dend_expend()* and *find_k()* functions of **dendextend** package will be used.

First, the *dend_expend()* will be used to determine the recommended clustering method to be used.

```{r}
wh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = "euclidean")
dend_expend(wh_d)[[3]]
```

```{r}
wh_clust <- hclust(wh_d, method = "average")
num_k <- find_k(wh_clust)
plot(num_k)
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          dist_method = "euclidean",
          hclust_method = "average",
          k_row = 3)
```

### **Seriation**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "OLO")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "GW")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "mean")
```

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none")
```

### **Working with colour palettes**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none",
          colors = Blues)
```

::: callout-note
i try with different colour
:::

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          seriate = "none",
           colors = heat.colors(100))
```

### **The finishing touch**

```{r}
heatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),
          Colv=NA,
          seriate = "none",
          colors = Blues,
          k_row = 5,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="World Happiness Score and Variables by Country, 2018 \nDataTransformation using Normalise Method",
          xlab = "World Happiness Indicators",
          ylab = "World Countries"
          )
```

# **4. Visual Multivariate Analysis with Parallel Coordinates Plot**

## **Installing and Launching R Packages**

```{r}
pacman::p_load(GGally, parallelPlot, tidyverse)
```

## **Data Preparation**

```{r}
wh <- read_csv("data/WHData-2018.csv")
```

## **Plotting Static Parallel Coordinates Plot**

Code chunk below shows a typical syntax used to plot a basic static parallel coordinates plot by usingÂ `ggparcoord()`.

```{r}
ggparcoord(data = wh, 
           columns = c(7:12))
```

### **Plotting a parallel coordinates with boxplot**

I will do a makeover the plot by using a collection of arguments provided byÂ `ggparcoord()`.

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Parallel Coordinates Plot of World Happines Variables")
```

### **Parallel coordinates with facet**

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region)
```

### **Rotating x-axis text label**

To make the x-axis text label easy to read, let us rotate the labels by 30 degrees. We can rotate axis text labels usingÂ `theme()`Â function in ggplot2 as shown in the code chunk below

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30))
```

### **Adjusting the rotated x-axis text label**

Rotating x-axis text labels to 30 degrees makes the label overlap with the plot and we can avoid this by adjusting the text location usingÂ `hjust`Â argument to theme's text element withÂ `element_text()`. We useÂ `axis.text.x`Â as we want to change the look of x-axis text.

```{r}
ggparcoord(data = wh, 
           columns = c(7:12), 
           groupColumn = 2,
           scale = "uniminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of World Happines Variables by Region") +
  facet_wrap(~ Region) + 
  theme(axis.text.x = element_text(angle = 30, hjust=1))
```

## **Plotting Interactive Parallel Coordinates Plot: parallelPlot methods**

The code chunk below plot an interactive parallel coordinates plot by usingÂ `parallelPlot()`.

```{r}
wh <- wh %>%
  select("Happiness score", c(7:12))
parallelPlot(wh,
             width = 320,
             height = 250)
```

### **Rotate axis label**

In the code chunk below,Â `rotateTitle`Â argument is used to avoid overlapping axis labels.

```{r}
parallelPlot(wh,
             rotateTitle = TRUE)
```

### **Changing the colour scheme**

We can change the default blue colour scheme by usingÂ `continousCS`Â argument as shown in the code chunk below.

```{r}
parallelPlot(wh,
             continuousCS = "YlOrRd",
             rotateTitle = TRUE)
```

### **Parallel coordinates plot with histogram**

In the code chunk below,Â `histoVisibility`Â argument is used to plot histogram along the axis of each variables.

```{r}
histoVisibility <- rep(TRUE, ncol(wh))
parallelPlot(wh,
             rotateTitle = TRUE,
             histoVisibility = histoVisibility)
```

# **5. Treemap Visualisation with R**

## **Installing and Launching R Packages**

```{r}
pacman::p_load(treemap, treemapify, tidyverse) 
```

## **Data Wrangling**

### **Importing the data set**

```{r}
realis2018 <- read_csv("data/realis2018.csv")
```

### **Data Wrangling and Manipulation**

### **Grouped summaries without the Pipe**

The code chunk below shows a more efficient way to tackle the same processes by using theÂ *pipe*, %\>%:

### **Grouped summaries with the *pipe***

```{r}
realis2018_summarised <- realis2018 %>% 
  group_by(`Project Name`,`Planning Region`, 
           `Planning Area`, `Property Type`, 
           `Type of Sale`) %>%
  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), 
            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),
            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),
            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))
```

## **Designing Treemap with treemap Package**

### **Designing a static treemap**

First, we will select records belongs to resale condominium property type fromÂ *realis2018_selected*Â data frame.

```{r}
realis2018_selected <- realis2018_summarised %>%
  filter(`Property Type` == "Condominium", `Type of Sale` == "Resale")
```

### **Using the basic arguments**

The code chunk below designed a treemap by using three core arguments ofÂ *treemap()*, namely:Â *index*,Â *vSize*Â andÂ *vColor*.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **Working with *vColor* and *type* arguments**

In the code chunk below,Â *type*Â argument is define as value.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type = "value",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **Colours in treemap package**

### **The "value" type treemap**

The code chunk below shows a value type treemap.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="value",
        palette="RdYlBu", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **The "manual" type treemap**

The code chunk below shows a manual type treemap.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="RdYlBu", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **Treemap Layout**

### **Working with *algorithm* argument**

The code chunk below plots a squarified treemap by changing theÂ *algorithm*Â argument.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        algorithm = "squarified",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

### **Using *sortID***

When "pivotSize" algorithm is used,Â *sortID*Â argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.

```{r}
treemap(realis2018_selected,
        index=c("Planning Region", "Planning Area", "Project Name"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="manual",
        palette="Blues", 
        algorithm = "pivotSize",
        sortID = "Median Transacted Price",
        title="Resale Condominium by Planning Region and Area, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

## **Designing Treemap using treemapify Package**

### **Designing a basic treemap**

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`),
       layout = "scol",
       start = "bottomleft") + 
  geom_treemap() +
  scale_fill_gradient(low = "light blue", high = "blue")
```

### **Defining hierarchy**

Group by Planning Region

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`),
       start = "topleft") + 
  geom_treemap()
```

Group by Planning Area

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`,
           subgroup2 = `Planning Area`)) + 
  geom_treemap()
```

Adding boundary line

```{r}
ggplot(data=realis2018_selected, 
       aes(area = `Total Unit Sold`,
           fill = `Median Unit Price ($ psm)`,
           subgroup = `Planning Region`,
           subgroup2 = `Planning Area`)) + 
  geom_treemap() +
  geom_treemap_subgroup2_border(colour = "gray40",
                                size = 2) +
  geom_treemap_subgroup_border(colour = "gray20")
```

## **Designing Interactive Treemap using d3treeR**

### **Installing *d3treeR* package**

```{r}
#| eval: false
install.packages("devtools")
```

```{r}
library(devtools)
install_github("timelyportfolio/d3treeR")
```

```{r}
library(d3treeR)
```

### **Designing An Interactive Treemap**

1.  *treemap()* is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object called ***tm***.

```{r}
tm <- treemap(realis2018_summarised,
        index=c("Planning Region", "Planning Area"),
        vSize="Total Unit Sold",
        vColor="Median Unit Price ($ psm)",
        type="value",
        title="Private Residential Property Sold, 2017",
        title.legend = "Median Unit Price (S$ per sq. m)"
        )
```

2.  Then *d3tree()* is used to build an interactive treemap.

```{r}
d3tree(tm,rootname = "Singapore" )
```
